{
  "name": "smtp-protocol",
  "description": "implements the smtp protocol for clients and servers",
  "version": "2.4.6",
  "repository": {
    "type": "git",
    "url": "git://github.com/substack/node-smtp-protocol.git"
  },
  "main": "index.js",
  "keywords": [
    "email",
    "mail",
    "smtp",
    "client",
    "server"
  ],
  "directories": {
    "lib": ".",
    "example": "example",
    "test": "test"
  },
  "scripts": {
    "test": "tap test/*.js"
  },
  "dependencies": {
    "through": "^2.3.4",
    "through2": "^1.0.0",
    "stream-combiner": "~0.0.2",
    "shallow-copy": "~0.0.1"
  },
  "devDependencies": {
    "tap": "~0.4.4",
    "chunky": "~0.0.0",
    "seq": "0.3.x",
    "concat-stream": "~1.2.0",
    "split": "~0.2.10"
  },
  "license": "MIT",
  "author": {
    "name": "James Halliday",
    "email": "mail@substack.net",
    "url": "http://substack.net"
  },
  "readme": "# smtp-protocol\n\nwrite smtp clients and servers\n\nThis module does not relay any messages or perform disk I/O by itself.\n\n[![build status](https://secure.travis-ci.org/substack/node-smtp-protocol.png)](http://travis-ci.org/substack/node-smtp-protocol)\n\n# examples\n\n## server\n\n``` js\nvar smtp = require('smtp-protocol');\n\nvar server = smtp.createServer(function (req) {\n    req.on('to', function (to, ack) {\n        var domain = to.split('@')[1] || 'localhost';\n        if (domain === 'localhost') ack.accept()\n        else ack.reject()\n    });\n    \n    req.on('message', function (stream, ack) {\n        console.log('from: ' + req.from);\n        console.log('to: ' + req.to);\n        \n        stream.pipe(process.stdout, { end : false });\n        ack.accept();\n    });\n});\n\nserver.listen(9025);\n```\n\nusage:\n\n```\n$ node example/server.js \n```\n\nelsewhere:\n\n```\n$ nc localhost 9025\n250 beep\nhelo\n250 \nmail from: <beep@localhost>\n250 \nrcpt to: <boop@localhost>\n250 \ndata\n354 \nBeep boop.\nI am a computer.\n.\n250 \nquit\n221 Bye!\n```\n\nmeanwhile:\n\n```\nfrom: beep@localhost\nto: boop@localhost\nBeep boop.\nI am a computer.\n```\n\n## client\n\n``` js\nvar smtp = require('smtp-protocol');\nvar fs = require('fs');\n\nsmtp.connect('localhost', 9025, function (mail) {\n    mail.helo('example.com');\n    mail.from('substack@example.com');\n    mail.to('root@example.com');\n    mail.data();\n    fs.createReadStream('/etc/issue').pipe(mail.message());\n    mail.quit();\n});\n```\n\noutput:\n\n```\n$ node example/client.js\n[ 'beep ESMTP Postfix (Ubuntu)' ]\n{ helo: 250,\n  from: 250,\n  to: 250,\n  data: 354,\n  message: 250,\n  quit: 221 }\n```\n\n# server methods\n\nvar smtp = require('smtp-protocol')\n\n## smtp.createServer(opts, cb)\n\nReturn a new `net.Server` so you can `.listen()` on a port.\n\nOptionally:\n\n* `opts.domain` - domain to use in hello message\n* `opts.tls` - listen on TLS at the start instead of upgrading with STARTTLS\n* `opts.key`, `opts.cert`, `opts.pfx` - configure tls\n\n`cb(req)` fires for new connection. See the \"requests\" section below.\n\n# server requests\n\n## events\n\nEvery event that can \n\nEvery acknowledgeable event except \"message\" will implicitly call `ack.accept()`\nif no listeners are registered.\n\nIf there are any listeners for an acknowledgeable event, exactly one listener\nMUST call either `ack.accept()` or `ack.reject()`.\n\n### 'command', cmd, r\n\nThis event fires for every smtp command. `cmd` has the command name as\n`cmd.name` and the `cmd.data` as the command data.\n\nIf you want to override the default behavior for a command, call\n`r.preventDefault()`, then call `r.write(code, data)` to write a response and\n`r.next()` when the next command should be processed.\n\n### 'greeting', cmd, ack\n\nEmitted when `HELO`, `EHLO`, or `LHLO` commands are received.\n\nRead the name of the command with `cmd.greeting`.\nRead the optional hostname parameter with `cmd.hostname`.\n\n### 'from', from, ack\n\nEmitted when the `MAIL FROM:` command is received.\n\n`from` is the email address of the sender as a string.\n\n### 'to', to, ack\n\nEmitted when the `RCPT TO:` command is received.\n\n`to` is the email address of the recipient as a string.\n\n### 'message', stream, ack\n\nEmitted when the `DATA` command is received.\n\nIf the message request is accepted, the message body will be streamed through\n`stream`.\n\nThis event has no implicit `ack.accept()` when there are no listeners.\n\n### 'received', ack\n\nEmitted when the body after the `DATA` command finishes.\n\n### 'reset'\n\nEmitted when the connection is reset from a `RSET` command.\n\n### 'quit'\n\nEmitted when the connection is closed from a `QUIT` command.\n\n### 'tls'\n\nEmitted when the connection is upgraded to TLS by the client.\n\n## properties\n\n### req.from\n\nThe email address of the sender as a string.\n\n### req.fromExt\n\nExtended sender data if sent as a string.\n\n### req.to\n\nArray of the email addresses of the recipients as a string.\n\n### req.toExt\n\nArray of extended recipient data if sent as a string.\n\n### req.greeting\n\nThe greeting command. One of `'helo'`, `'ehlo'`, or `'lhlo'`.\n\n### req.hostname\n\nThe hostname specified in the greeting.\n\n### req.socket\n\nThe underlying tcp socket. This is handy if you need to verify the address of\nthe remote host with `req.socket.remoteAddress`.\n\n# server acknowledgements\n\nMany request events have a trailing `ack` parameter.\n\nIf there are any listeners for an acknowledgeable event, exactly one listener\nMUST call either `ack.accept()` or `ack.reject()`.\n\nConsult [this handy list of SMTP codes](http://www.greenend.org.uk/rjk/2000/05/21/smtp-replies.html#SEND)\nfor which codes to use in acknowledgement responses.\n\n## ack.accept(code=250, message)\n\nAccept the command. Internal staged state modifications from the command are executed.\n\n## ack.reject(code, message)\n\nReject the command. Any staged state modifications from the command are discarded.\n\n# client methods\n\nFor all `client` methods, `cb(err, code, lines)` fires with the server response.\n\n## var stream = smtp.connect(host='localhost', port=25, options={}, cb)\n\nCreate a new SMTP client connection.\n\n`host`, `port`, `options` and `cb` are detected by their types in the arguments array so\nthey may be in any order. `cb(client)` fires when the connection is ready.\n\nYou can use unix sockets by supplying a string argument that matches `/^[.\\/]/`.\n\nAlternatively supply your own stream as `opts.stream` (the stream must already be connected).\n\nTo make a connection using TLS, set `opts.tls` to `true` (for more control you can also assign\noptions to pass through to `tls.connect`.) You can also upgrade the connection\nto TLS at any time by calling `client.startTLS()`.\n\nBy default, connections to unauthorized servers will be closed and the error\nwill be emitted as an `'error'` event on the stream object but you can provide\nyour own authorization logic by doing:\n\n``` js\nstream.on('secure', function (ack) {\n    if (...) ack.accept()\n    else ack.reject()\n})\n```\n\n## client.helo(hostname, cb)\n\nGreet the server with the `hostname` string.\n\n`cb(err, code, lines)` fires with the server response.\n\n## client.from(addr, ext=undefined, cb)\n\nSet the sender to the email address `addr` with optional extension data `ext`.\n\n`cb(err, code, lines)` fires with the server response.\n\n## client.to(addr, ext=undefined, cb)\n\nSet the recipient to the email address `addr` with optional extension data `ext`.\n\n`cb(err, code, lines)` fires with the server response.\n\n## client.data(cb)\n\nTell the server that we are about to transmit data.\n\n`cb(err, code, lines)` fires with the server response.\n\n## var stream = client.message(cb)\n\nReturn a writable stream to send data to the server in a message body.\nFor example, you could do:\n\n``` js\nfs.createReadStream('foo.txt').pipe(client.message());\n```\n\n`cb(err, code, lines)` fires with the server response.\n\n## client.quit(cb)\n\nAsk the server to sever the connection.\n\n`cb(err, code, lines)` fires with the server response.\n\n## client.reset(cb)\n\nAsk the server to reset the connection.\n\n`cb(err, code, lines)` fires with the server response.\n\n## client.startTLS(opts={}, cb)\n\nUpgrade the current connection to TLS with `opts` passed through to\n`tls.connect(opts)`.\n\nIf `opts.servername` isn't given, its value will be taken from the HELO/EHLO\nhostname value because otherwise the TLS library will complain about how the\ncertificate name doesn't match.\n\nYou'll probably want to pass in the `opts.ca` here as well to satisfy the TLS\nmachinery.\n\n## client.verify(username, cb)\n\nSend a VRFY for `username`.\n\n`cb(err, code, lines)` fires with the server response.\n\n## client.login(username, password, authType, cb)\n\nLogin with the given username and password. `authType` can be one of `PLAIN`, `LOGIN` and `CRAM-MD5`.\n\n`cb(err, code, lines)` fires with the server response.\n\n# client events\n\n## 'greeting', code, lines\n\nFired when the stream initializes. This should be the first message that the\nserver sends.\n\n## 'tls', clearTextStream\n\nWhen the connection is upgraded to TLS, this event fires.\n\n# install\n\nWith [npm](http://npmjs.org) do:\n\n```\nnpm install smtp-protocol\n```\n\n# license\n\nMIT\n",
  "readmeFilename": "readme.markdown",
  "bugs": {
    "url": "https://github.com/substack/node-smtp-protocol/issues"
  },
  "homepage": "https://github.com/substack/node-smtp-protocol",
  "_id": "smtp-protocol@2.4.6",
  "_from": "smtp-protocol@"
}
